import { storage, simulateDelay, generateId } from './core';
import { STORAGE_KEYS } from './types';
import type { User, Document, Analysis, Notification } from './types';

// Default User for initial setup
const DEFAULT_USER: User = {
  id: 'user_1',
  name: 'Demo User',
  email: 'demo@glassmind.ai',
  role: 'user',
  preferences: {
    theme: 'dark',
    language: 'en',
    timezone: 'utc',
    notifications: {
      emailAnalysis: true,
      emailUpdates: true,
      desktop: true
    }
  }
};

export const authService = {
  async login(email: string): Promise<User> {
    await simulateDelay(500, 1500);
    // Simple mock: accept any email, but check for 'error'
    if (email.includes('error')) {
      throw new Error('Invalid credentials');
    }

    // Retrieve existing user or create default
    let user = storage.get<User>(STORAGE_KEYS.USER_SETTINGS);
    if (!user) {
      user = { ...DEFAULT_USER, email };
      storage.set(STORAGE_KEYS.USER_SETTINGS, user);
    }

    storage.set(STORAGE_KEYS.AUTH_TOKEN, 'mock-jwt-token-' + generateId());
    return user;
  },

  async logout(): Promise<void> {
    await simulateDelay(200, 500);
    storage.remove(STORAGE_KEYS.AUTH_TOKEN);
  },

  async getCurrentUser(): Promise<User | null> {
    await simulateDelay(200, 500);
    const token = storage.get(STORAGE_KEYS.AUTH_TOKEN);
    if (!token) return null;
    return storage.get<User>(STORAGE_KEYS.USER_SETTINGS) || DEFAULT_USER;
  },

  async updateProfile(updates: Partial<User>): Promise<User> {
      await simulateDelay();
      const current = storage.get<User>(STORAGE_KEYS.USER_SETTINGS) || DEFAULT_USER;
      const updated = { ...current, ...updates };
      storage.set(STORAGE_KEYS.USER_SETTINGS, updated);
      return updated;
  }
};

export const documentService = {
  async getAll(): Promise<Document[]> {
    await simulateDelay();
    return storage.get<Document[]>(STORAGE_KEYS.DOCUMENTS) || [];
  },

  async upload(file: File): Promise<Document> {
    await simulateDelay(1000, 3000); // Simulate upload time

    // In a real app we'd upload to S3. Here we might store base64 if small,
    // but for large files in localStorage we might hit limits.
    // We'll store metadata and a fake content flag for now to be safe,
    // or very truncated content.

    const newDoc: Document = {
      id: generateId(),
      name: file.name,
      size: file.size,
      type: file.type,
      uploadDate: new Date().toISOString(),
      status: 'ready'
    };

    const docs = storage.get<Document[]>(STORAGE_KEYS.DOCUMENTS) || [];
    storage.set(STORAGE_KEYS.DOCUMENTS, [newDoc, ...docs]);

    // Trigger notification
    await notificationService.create({
        type: 'success',
        title: 'Upload Complete',
        message: `${file.name} has been successfully uploaded.`
    });

    return newDoc;
  },

  async delete(id: string): Promise<void> {
    await simulateDelay();
    const docs = storage.get<Document[]>(STORAGE_KEYS.DOCUMENTS) || [];
    storage.set(STORAGE_KEYS.DOCUMENTS, docs.filter(d => d.id !== id));
  }
};

export const analysisService = {
  async getAll(): Promise<Analysis[]> {
    await simulateDelay();
    return storage.get<Analysis[]>(STORAGE_KEYS.ANALYSES) || [];
  },

  async create(question: string, documentIds: string[]): Promise<Analysis> {
    await simulateDelay(500); // Initial creation is fast

    const newAnalysis: Analysis = {
      id: generateId(),
      question,
      documentIds,
      result: '',
      createdAt: new Date().toISOString(),
      status: 'processing'
    };

    const analyses = storage.get<Analysis[]>(STORAGE_KEYS.ANALYSES) || [];
    storage.set(STORAGE_KEYS.ANALYSES, [newAnalysis, ...analyses]);

    // Simulate async processing
    this.processAnalysis(newAnalysis.id);

    return newAnalysis;
  },

  // Internal helper to simulate the "Agent" working in background
  async processAnalysis(id: string) {
      setTimeout(() => {
          const analyses = storage.get<Analysis[]>(STORAGE_KEYS.ANALYSES) || [];
          const index = analyses.findIndex(a => a.id === id);
          if (index !== -1) {
              analyses[index].status = 'completed';
              analyses[index].result = `Analysis for "${analyses[index].question}" completed successfully. \n\nThis is a simulated response generated by the local mock engine. In a real scenario, this would be the output from the AI agent processing documents: ${analyses[index].documentIds.join(', ')}.`;
              storage.set(STORAGE_KEYS.ANALYSES, analyses);

              notificationService.create({
                  type: 'success',
                  title: 'Analysis Ready',
                  message: 'Your analysis has been completed.'
              });
          }
      }, 5000); // 5 seconds processing time
  }
};

export const notificationService = {
  async getAll(): Promise<Notification[]> {
    await simulateDelay();
    return storage.get<Notification[]>(STORAGE_KEYS.NOTIFICATIONS) || [];
  },

  async markAsRead(id: string): Promise<void> {
    await simulateDelay(100);
    const notifs = storage.get<Notification[]>(STORAGE_KEYS.NOTIFICATIONS) || [];
    const updated = notifs.map(n => n.id === id ? { ...n, read: true } : n);
    storage.set(STORAGE_KEYS.NOTIFICATIONS, updated);
  },

  async markAllAsRead(): Promise<void> {
    await simulateDelay(300);
    const notifs = storage.get<Notification[]>(STORAGE_KEYS.NOTIFICATIONS) || [];
    const updated = notifs.map(n => ({ ...n, read: true }));
    storage.set(STORAGE_KEYS.NOTIFICATIONS, updated);
  },

  async create(notification: Omit<Notification, 'id' | 'date' | 'read'>): Promise<Notification> {
      // Internal use, minimal delay
      const newNotif: Notification = {
          id: generateId(),
          date: new Date().toISOString(),
          read: false,
          ...notification
      };

      const notifs = storage.get<Notification[]>(STORAGE_KEYS.NOTIFICATIONS) || [];
      storage.set(STORAGE_KEYS.NOTIFICATIONS, [newNotif, ...notifs]);
      return newNotif;
  },

  async delete(id: string): Promise<void> {
      await simulateDelay();
      const notifs = storage.get<Notification[]>(STORAGE_KEYS.NOTIFICATIONS) || [];
      storage.set(STORAGE_KEYS.NOTIFICATIONS, notifs.filter(n => n.id !== id));
  }
};
